---
title: 漏洞保护参考
keywords: 缓解, 漏洞, 漏洞, 缓解, 攻击, 攻击, emet
description: 有关 Exploit Protection 功能如何工作的详细信息Windows
ms.pagetype: security
ms.prod: m365-security
ms.mktglfcycl: manage
ms.sitesec: library
ms.localizationpriority: medium
audience: ITPro
author: denisebmsft
ms.author: deniseb
ms.reviewer: cjacks
manager: dansimp
ms.custom: asr
ms.technology: mde
ms.topic: article
ms.collection: m365-security-compliance
ms.date: 10/19/2021
ms.openlocfilehash: f6889cb12f1a152abe3dbb7d748d52e118547ab3
ms.sourcegitcommit: bdd6ffc6ebe4e6cb212ab22793d9513dae6d798c
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/08/2022
ms.locfileid: "63324113"
---
# <a name="exploit-protection-reference"></a>Exploit Protection 参考

[!INCLUDE [Microsoft 365 Defender rebranding](../../includes/microsoft-defender.md)]


**适用于：**
- [Microsoft Defender for Endpoint 计划 2](https://go.microsoft.com/fwlink/?linkid=2154037)
- [Microsoft 365 Defender](https://go.microsoft.com/fwlink/?linkid=2118804)

> 希望体验 Microsoft Defender for Endpoint？ [注册免费试用版](https://signup.microsoft.com/create-account/signup?products=7f379fee-c4f9-4278-b0a1-e4c8c2fcdf7e&ru=https://aka.ms/MDEp2OpenTrial?ocid=docs-wdatp-enablesiem-abovefoldlink)。

Exploit Protection 为 IT 部门在编译和分发软件Pro应用的高级保护。

本文将帮助你了解 Exploit Protection 在策略级别和个别缓解级别的工作方式，以帮助你成功构建和应用 Exploit Protection 策略。

## <a name="how-mitigations-are-applied"></a>如何应用缓解

Exploit Protection 缓解按应用程序应用。

缓解通过为每个配置保护的程序的注册表项进行配置。 这些设置存储在每个程序 (**HKEY_LOCAL_MACHINE \ SOFTWARE \ Microsoft \ Windows NT \ CurrentVersion \ Image File Execution Options \ *ImageFileName* \ MitigationOptions) 的 MitigationOptions** 注册表项中。 它们在您重新启动程序后生效，并一直有效，直到您更改它们并再次重新启动该程序。

> [!IMPORTANT]
> Image File Execution Options only allows you to specify a file name or path， not a version number， architecture， or any other differentiator. 请注意将缓解目标定向到具有唯一名称或路径的应用，仅将它们应用到已测试该版本和应用程序的该体系结构的设备上。

如果使用 XML 配置文件（通过 PowerShell、组策略或 MDM）配置 Exploit Protection 缓解，在处理此 XML 配置文件时，将针对你配置各个注册表设置。

当不再强制执行分发 XML 文件的策略时，不会自动删除此 XML 配置文件部署的设置。 若要删除 Exploit Protection 设置，请从干净或Windows 10 Windows 11 XML 配置，并部署此新的 XML 文件。 或者，Microsoft 提供 XML 文件作为重置 Exploit Protection Windows 安全中心基线的一部分。

若要使用 PowerShell 重置 Exploit Protection 设置，可以使用以下命令：

```powershell
Set-ProcessMitigation -PolicyFilePath EP-reset.xml
```
下面是随EP-reset.xml比较基准Windows 安全中心分布的比较基准：
```xml
<?xml version="1.0" encoding="UTF-8"?>
<MitigationPolicy>
  <AppConfig Executable="ONEDRIVE.EXE">
    <DEP OverrideDEP="false" />
    <ASLR OverrideRelocateImages="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
  </AppConfig>
  <AppConfig Executable="firefox.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
  </AppConfig>
  <AppConfig Executable="fltldr.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
    <ChildProcess OverrideChildProcess="false" />
  </AppConfig>
  <AppConfig Executable="GROOVE.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
    <ChildProcess OverrideChildProcess="false" />
  </AppConfig>
  <AppConfig Executable="Acrobat.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="AcroRd32.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="chrome.exe">
    <DEP OverrideDEP="false" />
  </AppConfig>
  <AppConfig Executable="EXCEL.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="iexplore.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="INFOPATH.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="java.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="javaw.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="javaws.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="LYNC.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="MSACCESS.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="MSPUB.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="OIS.EXE">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="OUTLOOK.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="plugin-container.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="POWERPNT.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="PPTVIEW.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="VISIO.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="VPREVIEW.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="WINWORD.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="wmplayer.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="wordpad.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
</MitigationPolicy>
```

## <a name="mitigation-reference"></a>缓解参考

以下各节详细介绍了每个 Exploit Protection 缓解所提供的保护、缓解的兼容性注意事项以及可用的配置选项。

## <a name="arbitrary-code-guard"></a>任意代码保护

### <a name="description"></a>说明

任意代码防护可帮助防止恶意攻击者通过内存安全漏洞将所选择的代码加载到内存中，并能够执行该代码。

任意代码保护保护应用程序，防止在未加载 (（例如，来自 exe 本身或 dll) ）的代码中执行动态生成的代码。 任意代码保护通过阻止内存标记为可执行文件来工作。 当应用程序尝试分配 [内存时](/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc)，我们将检查保护标志。  (内存可以使用读取、写入和/或执行保护标志进行分配。) 如果分配尝试包含执行保护标志，则内存分配将失败并返回错误代码 [](/windows/win32/memory/memory-protection-constants) (STATUS_DYNAMIC_CODE_BLOCKED) 。 同样，如果应用程序尝试更改已分配[](/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect)并包含执行保护标志的内存的保护标志，则权限更改将失败，[](/windows/win32/memory/memory-protection-constants)并返回错误代码 (STATUS_DYNAMIC_CODE_BLOCKED) 。

通过阻止 *设置执行* 标志，Windows 10 和 Windows 11 的数据执行保护功能可以防范被设置为该内存并运行该代码的指令指针。

### <a name="compatibility-considerations"></a>兼容性注意事项

任意代码保护可阻止将任何内存分配为可执行文件，这给 JIT 编译器等方法 (兼容性) 问题。 例如，大多数新式浏览器都会将 JavaScript 编译为本机代码，以优化性能。 为了支持此缓解，需要重新检测它们，以将 JIT 编译移动到受保护进程之外。 其设计从脚本或其他中间语言动态生成代码的其他应用程序与此缓解类似不兼容。

### <a name="configuration-options"></a>配置选项

**允许线程退出** - 你可以配置缓解，以允许单个线程选择退出此保护。 开发人员必须已编写了解此缓解的应用程序，并且已调用 [**SetThreadInformation**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadinformation) API，将 *ThreadInformation* 参数设置为 **ThreadDynamicCodePolicy** ，以便允许在此线程上执行动态代码。

**仅审核** - 可以在审核模式下启用此缓解，以便衡量对应用程序的潜在兼容性影响。 然后，可以在事件查看器中或在 Defender for Endpoint 中使用高级搜寻 [查看审核事件](/microsoft-365/security/defender/advanced-hunting-overview)。

## <a name="block-low-integrity-images"></a>阻止低完整性图像

### <a name="description"></a>说明

阻止低完整性图像会阻止应用程序加载不受信任的文件，通常是因为它们从沙盒浏览器从 Internet 下载。

如果映像具有访问控制项 (ACE) 则此缓解将阻止映像加载) 该条目授予对低 IL 进程的访问权限，并且该进程没有信任标签 ACE。 它由内存管理器实现，它会阻止将文件映射到内存。 如果应用程序尝试映射低完整性映像，它将触发STATUS_ACCESS_DENIED错误。 有关完整性级别如何工作的详细信息，请参阅 [强制完整性控制](/windows/win32/secauthz/mandatory-integrity-control)。

### <a name="compatibility-considerations"></a>兼容性注意事项

阻止低完整性映像将阻止应用程序加载从 Internet 下载的文件。 如果应用程序工作流需要加载已下载的图像，则需要确保它们从高信任进程下载，或者为了应用此缓解而明确重新标记。

### <a name="configuration-options"></a>配置选项

**仅审核** - 可以在审核模式下启用此缓解，以便衡量对应用程序的潜在兼容性影响。 然后，可以在事件查看器中或在 [Microsoft Defender for Endpoint](/microsoft-365/security/defender/advanced-hunting-overview) 中使用高级搜寻查看审核事件。

## <a name="block-remote-images"></a>阻止远程图像

### <a name="description"></a>说明

阻止远程映像有助于防止应用程序加载在远程设备上托管的文件，例如 UNC 共享。 阻止远程映像有助于防止将二进制文件加载到由攻击者控制的外部设备上的内存。

如果图像确定位于远程设备上，此缓解将阻止映像加载。 它由内存管理器实现，它会阻止将文件映射到内存。 如果应用程序尝试映射远程文件，它将触发STATUS_ACCESS_DENIED错误。

### <a name="compatibility-considerations"></a>兼容性注意事项

阻止远程图像将阻止应用程序从远程设备加载图像。 如果你的应用程序从远程设备加载文件或插件，它将与此缓解不兼容。

### <a name="configuration-options"></a>配置选项

**仅审核** - 可以在审核模式下启用此缓解，以便衡量对应用程序的潜在兼容性影响。 然后，可以在事件查看器中或在 [Microsoft Defender for Endpoint](/microsoft-365/security/defender/advanced-hunting-overview) 中使用高级搜寻查看审核事件。

## <a name="block-untrusted-fonts"></a>阻止不受信任的字体

### <a name="description"></a>说明

阻止不受信任的字体可以减少字体分析中缺陷的风险，从而导致攻击者能够在设备上运行代码。 只有安装到 windows\fonts 目录中的字体将被 GDI 加载进行处理。

此缓解措施在 GDI 中实现，可验证文件的位置。 如果文件不在系统字体目录中，将不会加载该字体进行分析，并且该调用将失败。

除了 Windows 10 1607 及更高版本和 Windows 11 中提供的内置缓解外，此缓解功能将字体分析从内核移入用户模式应用容器。 因此，基于字体分析的任何攻击都发生在沙盒和隔离的上下文中，这大大降低了风险。 有关此缓解的详细信息，请参阅博客使用零Windows 10[攻击缓解进行强化](https://www.microsoft.com/security/blog/2017/01/13/hardening-windows-10-with-zero-day-exploit-mitigations/)。

### <a name="compatibility-considerations"></a>兼容性注意事项

系统字体目录之外的字体的最常见用途是使用 [Web 字体](/typography/fonts/font-faq#web)。 新式浏览器（如 Microsoft Edge）DirectWrite GDI，并且不会受到影响。 但是，新 Microsoft Edge) 中的旧版浏览器（如 Internet Explorer 11 (和 IE 模式）可能会受到影响，特别是对于使用字体字形显示 UI 的应用程序（如 Office 365）。

### <a name="configuration-options"></a>配置选项

**仅审核** - 可以在审核模式下启用此缓解，以便衡量对应用程序的潜在兼容性影响。 然后，可以在事件查看器中或在 [Microsoft Defender for Endpoint](/microsoft-365/security/defender/advanced-hunting-overview) 中使用高级搜寻查看审核事件。

## <a name="code-integrity-guard"></a>代码完整性防护

### <a name="description"></a>说明

代码完整性防护可确保加载到进程的所有二进制文件都由 Microsoft 进行数字签名。 代码完整性防护包括 [WHQL](/windows-hardware/drivers/install/whql-release-signature) (Windows硬件质量) 签名，这将允许 WHQL 批准的驱动程序在进程中运行。

此缓解措施在内存管理器中实现，可阻止将二进制文件映射到内存。 如果尝试加载未由 Microsoft 签名的二进制文件，则内存管理器将返回错误STATUS_INVALID_IMAGE_HASH。 通过阻止内存管理器级别，这可以防止进程加载的二进制文件和注入到进程中的二进制文件。

### <a name="compatibility-considerations"></a>兼容性注意事项

此缓解功能专门阻止任何未由 Microsoft 签名的二进制文件。 因此，它将与大多数第三方软件不兼容，除非该软件由 (由) Microsoft Store 进行数字签名，并且选择允许加载由 Microsoft Store 签名的图像的选项。

### <a name="configuration-options"></a>配置选项

还允许加载 **由 Microsoft Store** 签名的图像 - Microsoft Store 分发的应用程序由 Microsoft Store 进行数字签名，添加此配置将允许应用程序加载通过应用商店认证过程的二进制文件。

**仅审核** - 可以在审核模式下启用此缓解，以便衡量对应用程序的潜在兼容性影响。 然后，可以在事件查看器中或在 [Microsoft Defender for Endpoint](/microsoft-365/security/defender/advanced-hunting-overview) 中使用高级搜寻查看审核事件。

## <a name="control-flow-guard-cfg"></a>控制流保护 (CFG) 

### <a name="description"></a>说明

控制流保护 (CFG) 通过保护间接函数调用来降低攻击者使用内存损坏漏洞的风险。 例如，攻击者可能会使用缓冲区溢出漏洞覆盖包含函数指针的内存，并使用指向其选择的可执行代码 (该指针替换该函数指针) 。

此缓解功能是在编译时注入另一个检查。 在每个间接函数调用之前，会添加另一个指令，该指令在调用目标之前验证该目标是否是有效的调用目标。 如果目标不是有效的呼叫目标，则应用程序将终止。 因此，只有使用 CFG 支持编译的应用程序可以从此缓解中获益。

检查有效目标由Windows提供。 加载可执行文件时，间接调用目标的元数据在加载时提取并标记为有效的调用目标。 此外，当分配内存并标记为可执行 (如生成的代码) 时，这些内存位置也会标记为有效的调用目标，以支持 JIT 编译等机制。

### <a name="compatibility-considerations"></a>兼容性注意事项

由于必须编译应用程序以支持 CFG，因此它们隐式声明其与 CFG 的兼容性。 因此，大多数应用程序都应使用已启用此缓解功能。 由于这些检查已编译为二进制文件，因此可以应用的配置只是为了在内核中禁用Windows检查。 换句话说，缓解默认启用，但你可以将 Windows 内核配置为始终返回"是"（如果你稍后确定应用程序开发人员在测试中未发现兼容性问题，这应该很少见）。

### <a name="configuration-options"></a>配置选项

使用 **严格的 CFG** - 在严格模式下，必须针对 Control Flow Guard (编译加载到进程中的所有二进制文件，或者这些二进制文件中没有任何可执行代码（如资源 dll) ）才能加载。

> [!Note]
> **控制流保护** 没有审核模式。 在启用此缓解功能后编译二进制文件。

## <a name="data-execution-prevention-dep"></a>数据执行保护(DEP)

### <a name="description"></a>说明

DEP (执行) 防止执行未明确分配为可执行文件的内存。 DEP 可帮助防止攻击者将恶意代码注入进程，例如通过缓冲区溢出，然后执行该代码。

如果尝试将指令指针设置为未标记为可执行的内存地址，处理器将在常规保护冲突 (引发异常) ，从而导致应用程序崩溃。

### <a name="compatibility-considerations"></a>兼容性注意事项

默认情况下，所有 x64、ARM 和 ARM-64 可执行文件都已启用 DEP，并且不能禁用。 由于应用程序永远不会在没有 DEP 的情况下执行，因此假定兼容性。

默认情况下，所有 x86 (32) 都启用了 DEP，但可以按进程禁用 DEP。 一些旧的旧应用程序（通常是在 Windows XP SP2 之前开发的应用程序）可能与 DEP 不兼容。 此类应用程序通常 (JIT 编译) 或链接到较早的库 (如动态生成代码的较早版本的 ATL) 。

### <a name="configuration-options"></a>配置选项

**启用 ATL Thunk 模拟** - 此配置选项禁用 ATL Thunk 模拟。 ATL 是ActiveX模板库，旨在尽可能小且快速。 为了减小二进制大小，它将使用一种称为 *"双* 叉"的技术。 图文通常被认为是在 32 位和 16 位应用程序之间交互，但此处没有用于 ATL 的 16 位组件。 相反，为了优化二进制大小，ATL 将在内存中存储与单词不一致的计算机代码 (创建较小的二进制) ，然后直接调用该代码。 使用 Visual Studio 7.1 或 (Visual Studio 2003) 编译的 ATL 组件不会分配此内存作为可执行文件 - thunk 模拟可解决该兼容性问题。 具有二进制扩展模型 (如 Internet Explorer 11) 通常需要启用 ATL Thunk 模拟。

## <a name="disable-extension-points"></a>禁用扩展点

### <a name="description"></a>说明

此缓解功能禁用应用程序的各种扩展点，这些扩展点可用于建立持久性或提升恶意内容的特权。

这包括：

- **AppInit DLL** - 只要进程启动，系统就会先将指定的 DLL 加载到新启动进程的上下文中，然后再调用其入口点函数。 [有关 AppInit DLL 的详细信息，请参阅此处](/windows/win32/winmsg/about-window-classes#application-global-classes)。 应用此缓解后，不会加载 AppInit DLL。 从 Windows 7 开始，AppInit DLL 需要进行数字签名[，如下所述](/windows/win32/win7appqual/appinit-dlls-in-windows-7-and-windows-server-2008-r2)。 此外，从 Windows 8开始，如果启用 SecureBoot，AppInit DLL 将不会加载[，如此处所述](/windows/win32/dlls/secure-boot-and-appinit-dlls)。
- **旧版 IME** - 输入法编辑器 (输入法) 输入法编辑器允许用户键入的字符数多于键盘上可表示的字符数的语言的文本。 第三方能够创建 IIM。 恶意 IME 可能会从此输入捕获获取凭据或其他敏感信息。 一些 IIM（称为传统 IIM）仅适用于Windows桌面应用，而非 UWP 应用。 此缓解还会阻止此旧版 IME 加载到指定的桌面Windows中。
- **Windows事件挂钩** - 应用程序可以调用 [SetWinEventHook API](/windows/win32/api/winuser/nf-winuser-setwineventhook) 来注册对事件发生的关注。 DLL 已指定，可以注入到进程中。 此缓解将强制将挂钩张贴到注册进程，而不是通过注入的 DLL 在进程内运行。

### <a name="compatibility-considerations"></a>兼容性注意事项

这些扩展点中的大多数相对很少使用，因此兼容性影响通常很小，尤其是在单个应用程序级别。 一个考虑事项是用户是否正在使用第三方旧版 IIM，这些 IES 将不能与受保护的应用程序一起使用。

### <a name="configuration-options"></a>配置选项

没有用于此缓解的配置选项。

> [!Note]
> **禁用扩展点** 没有审核模式。

## <a name="disable-win32k-system-calls"></a>禁用 Win32k 系统调用

### <a name="description"></a>说明

Win32k.sys攻击提供了广泛的攻击面。 作为内核模式组件，它通常作为沙盒应用程序的转义矢量进行定向。 此缓解措施win32k.sys线程自行转换为 GUI 线程，然后向该线程提供调用 Win32k 函数的访问权限，从而阻止调用。 线程创建时为非 GUI，但在首次调用线程时win32k.sys，或者通过 API 调用 [IsGuiThread 转换](/windows/win32/api/winuser/nf-winuser-isguithread)。

### <a name="compatibility-considerations"></a>兼容性注意事项

此缓解针对的是专用非 UI 进程的进程。 例如，许多新式浏览器将使用进程隔离并合并非 UI 进程。 使用单个进程显示 GUI 的任何应用程序都将受到此缓解的影响。

### <a name="configuration-options"></a>配置选项

**仅审核** - 可以在审核模式下启用此缓解，以便衡量对应用程序的潜在兼容性影响。 然后，可以在事件查看器中或在 [Microsoft Defender for Endpoint](/microsoft-365/security/defender/advanced-hunting-overview) 中使用高级搜寻查看审核事件。

## <a name="do-not-allow-child-processes"></a>不允许子进程

### <a name="description"></a>说明

此缓解阻止应用程序创建新的子应用程序。 攻击者使用的一种常见技术是在具有恶意输入的设备上启动受信任的进程 (称为"离开陆地"攻击) ，这通常需要在设备上启动另一个应用程序。 如果应用程序启动子进程没有任何合理原因，此缓解功能将缓解潜在的攻击途径。 通过设置进程令牌上的属性来应用缓解，这将阻止创建包含错误消息的子进程的STATUS_CHILD_PROCESS_BLOCKED。

### <a name="compatibility-considerations"></a>兼容性注意事项

如果你的应用程序出于任何原因启动子应用程序，例如支持启动浏览器或外部浏览器的超链接，或者在计算机上启动其他实用程序，则此功能将因应用的此缓解功能而中断。

### <a name="configuration-options"></a>配置选项

**仅审核** - 可以在审核模式下启用此缓解，以便衡量对应用程序的潜在兼容性影响。 然后，可以在事件查看器中或在 [Microsoft Defender for Endpoint](/microsoft-365/security/defender/advanced-hunting-overview) 中使用高级搜寻查看审核事件。

## <a name="export-address-filtering"></a>导出地址筛选

### <a name="description"></a>说明

使用 EAF (导出地址) 可以减少恶意代码查看所有已加载模块的导出地址表以查找包含用于攻击的有用 API 的模块的风险。 这是 shellcode 使用的常见策略。 为了降低此类攻击的风险，此缓解措施可保护三个经常受到攻击的模块：

- ntdll.dll
- kernelbase.dll
- kernel32.dll

缓解保护 [导出目录中指向导出地址表的内存 [页](/windows/win32/debug/pe-format#export-address-table)。 此内存页将应用 [PAGE_GUARD](/windows/win32/memory/creating-guard-pages) 保护。 当有人尝试访问此内存时，它将生成STATUS_GUARD_PAGE_VIOLATION。 缓解处理此异常，如果访问指令未通过验证，则进程将终止。

### <a name="compatibility-considerations"></a>兼容性注意事项

此缓解主要是调试程序、沙盒应用程序、使用 DRM 的应用程序或实现反调试技术的应用程序等应用程序的问题。

### <a name="configuration-options"></a>配置选项

**验证通常被** 攻击滥用的模块的访问 - 此选项（也称为 EAF+）可添加针对其他经常受到攻击的模块的保护：

- `mshtml.dll`
- `flash*.ocx`
- `jscript*.ocx`
- `vbscript.dll`
- `vgx.dll`
- `mozjs.dll`
- `xul.dll`
- `acrord32.dll`
- `acrofx32.dll`
- `acroform.api`

此外，通过启用 EAF+，此缓解功能将 PAGE_GUARD 保护添加到包含"MZ"标头（ [PE 文件中 DOS](/windows/win32/debug/pe-format#ms-dos-stub-image-only) 标头的前两个字节）的页面，这是 shellcode 可以查找以标识内存中可能感兴趣的模块的已知内存内容的另一个方面。

**仅审核** - 可以在审核模式下启用此缓解，以便衡量对应用程序的潜在兼容性影响。 然后，可以在事件查看器中或在 [Microsoft Defender for Endpoint](/microsoft-365/security/defender/advanced-hunting-overview) 中使用高级搜寻查看审核事件。

## <a name="force-randomization-for-images-mandatory-aslr"></a>强制图像随机化(强制 ASLR)

### <a name="description"></a>说明

地址空间布局随机化 (ASLR) 通过使用他们对系统内存布局的知识来降低攻击者的风险，以便执行进程内存中已存在且已标记为可执行的代码。 这可以减少攻击者使用技术（如返回到库式攻击）的风险，其中攻击者设置上下文，然后修改返回地址，以使用适合攻击者目的的上下文执行现有代码。

强制 ASLR 强制对进程内的所有 DLL 进行重基。 开发人员可以使用 [/DYNAMICBASE](/cpp/build/reference/dynamicbase-use-address-space-layout-randomization) 链接器选项启用 ASLR，此缓解功能也具有相同的效果。

当内存管理器在映像中映射到进程时，强制 ASLR 将强制重定位未选择加入 ASLR 的 DLL 和 EXES。 但请注意，这种重定基址没有向性，因此可放置在内存中的可预测位置。 对于二进制文件的重定基址和随机化位置，此缓解应该与从下而上 [ASLR ](#randomize-memory-allocations-bottom-up-aslr) (随机分配) 。

### <a name="compatibility-considerations"></a>兼容性注意事项

ASLR 的这种兼容性影响通常限定于使用编译器构建的、假定二进制文件基地址或去除基本重定位信息的较旧应用程序。 当执行流尝试跳转到内存中的预期位置（而不是实际位置）时，这可能会导致不可预知的错误。

### <a name="configuration-options"></a>配置选项

**不允许去除图像** - 此选项阻止加载已去除重定位信息的图像。 the Windows PE file format contains absolute addresses， and the compiler also generates a [base重定位 table that the loader can use to find all relative memory references and their offset， so they can be updated if the binary does not load at its preferred base address. 一些较旧的应用程序在生产内部版本上去除此信息，因此无法重定这些二进制文件的基础。 此缓解阻止此类二进制文件 (，而不是允许它们以首选基地址地址) 。

> [!Note]
> **强制图像随机化 (强制 ASLR)** 没有审核模式。

## <a name="import-address-filtering-iaf"></a>导入地址筛选(IAF)

### <a name="description"></a>说明

导入地址筛选 (IAF) 缓解功能通过修改导入地址表 (IAT) 以在调用该函数时重定向到攻击者选择的任意代码，帮助降低攻击者更改应用程序控制流的风险。 攻击者可能使用这种方法劫持控制，或截获、检查和潜在阻止对敏感 API 的调用。

所有受保护的 API 的内存页都将应用[PAGE_GUARD保护。](/windows/win32/memory/creating-guard-pages) 当有人尝试访问此内存时，它将生成STATUS_GUARD_PAGE_VIOLATION。 缓解处理此异常，如果访问指令未通过验证，则进程将终止。

此缓解功能可保护以下Windows API：

- `GetProcAddress`
- `GetProcAddressForCaller`
- `LoadLibraryA`
- `LoadLibraryExA`
- `LoadLibraryW`
- `LoadLibraryExW`
- `LdrGetProcedureAddress`
- `LdrGetProcedureAddressEx`
- `LdrGetProcedureAddressForCaller`
- `LdrLoadDll`
- `VirtualProtect`
- `VirtualProtectEx`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `NtProtectVirtualMemory`
- `CreateProcessA`
- `CreateProcessW`
- `WinExec`
- `CreateProcessAsUserA`
- `CreateProcessAsUserW`
- `GetModuleHandleA`
- `GetModuleHandleW`
- `RtlDecodePointer`
- `DecodePointer`

### <a name="compatibility-considerations"></a>兼容性注意事项

执行 API 拦截的合法应用程序可能会通过此缓解检测到，并会导致某些应用程序崩溃。 示例包括安全软件和应用程序兼容性填充程序。

### <a name="configuration-options"></a>配置选项

**仅审核** - 可以在审核模式下启用此缓解，以便衡量对应用程序的潜在兼容性影响。 然后，可以在事件查看器中或在 [Microsoft Defender for Endpoint](/microsoft-365/security/defender/advanced-hunting-overview) 中使用高级搜寻查看审核事件。

## <a name="randomize-memory-allocations-bottom-up-aslr"></a>从下向上 ASLR (随机分配) 

### <a name="description"></a>说明

随机内存分配 (从下向上的 ASLR) 向重定位添加反光，因此它们的位置是随机的，因此不太可预测。 此缓解要求强制 ASLR 生效。

32 位地址空间的大小对可添加的全向性设置实际约束，因此 64 位应用程序使攻击者更难猜测内存中的位置。

### <a name="compatibility-considerations"></a>兼容性注意事项

与强制 ASLR 和重基 (大多数) 也与下向上 ASLR 的其他各向性兼容。 如果一些应用程序将本地指针保存在 32 位变量中 (预期基地址低于 4 GB) ，则它们可能有指针截断问题，因此与高向异性选项 (可禁用) 。

### <a name="configuration-options"></a>配置选项

请勿使用高向 **异性 - 此选项** 禁止使用高向异性 ASLR，这会在 64 位应用程序的下向上分配中增加 24 位的 24 位 (1 TB 的方差) 。

> [!Note]
> **在无审核模式 (下向上 ASLR)** 随机分配内存。

## <a name="simulate-execution-simexec"></a>模拟执行(SimExec)

### <a name="description"></a>说明

模拟执行 (SimExec) 是 32 位应用程序的缓解措施。 这有助于验证对敏感 API 的调用是否将返回到合法的调用方函数。 它通过截获对敏感 API 的调用，然后通过浏览查找 RET 指令的编码程序集语言指令来模拟这些 API 的执行，该指令应返回到调用方。 然后检查该函数，在内存中向后移动以查找前面的 CALL 指令，以确定该函数和 CALL 指令是否匹配，以及 RET 尚未被截获。

此缓解截获的 API 包括：

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

如果检测到 ROP 小部件，则进程将终止。

### <a name="compatibility-considerations"></a>兼容性注意事项

执行 API 拦截的应用程序（尤其是安全软件）可能会导致此缓解出现兼容性问题。

此缓解与任意代码防护缓解不兼容。

### <a name="configuration-options"></a>配置选项

**仅审核** - 可以在审核模式下启用此缓解，以便衡量对应用程序的潜在兼容性影响。 然后，可以在事件查看器中或在 [Microsoft Defender for Endpoint](/microsoft-365/security/defender/advanced-hunting-overview) 中使用高级搜寻查看审核事件。

## <a name="validate-api-invocation-callercheck"></a>验证 API 调用(CallerCheck)

### <a name="description"></a>说明

Validate API invocation (CallerCheck) is a mitigation for return-oriented programming (ROP) techniques that validates that sensitive APIS were called from a valid caller. 此缓解将检查传递的返回地址，然后启发式反汇编以查找返回地址上方的调用，以确定调用目标是否与传入函数的参数匹配。

此缓解截获的 API 包括：

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

如果检测到 ROP 小部件，则进程将终止。

### <a name="compatibility-considerations"></a>兼容性注意事项

执行 API 拦截的应用程序（尤其是安全软件）可能会导致此缓解出现兼容性问题。

此缓解与任意代码防护缓解不兼容。

### <a name="configuration-options"></a>配置选项

**仅审核** - 可以在审核模式下启用此缓解，以便衡量对应用程序的潜在兼容性影响。 然后，可以在事件查看器中或在 [Microsoft Defender for Endpoint](/microsoft-365/security/defender/advanced-hunting-overview) 中使用高级搜寻查看审核事件。

## <a name="validate-exception-chains-sehop"></a>验证异常链(SEHOP)

### <a name="description"></a>说明

验证 SEHOP (是) *SEH* 覆盖利用技术 (异常处理程序) 缓解。 [结构化异常](/windows/win32/debug/structured-exception-handling) 处理是应用程序可以请求处理特定异常的过程。 异常处理程序链接在一起，因此，如果一个异常处理程序选择不处理特定异常，则它可以传递到链中的下一个异常处理程序，直到一个异常处理程序决定处理它。 由于处理程序列表是动态的，因此它存储在堆栈上。 攻击者可以使用堆栈溢出漏洞，然后使用指向攻击者选择的代码的指针覆盖异常处理程序。

此缓解依赖于 SEH 的设计，其中每个 SEH 条目都包含指向异常处理程序的指针，以及指向异常链中下一个处理程序的指针。 此缓解由异常调度程序调用，该调度程序在调用异常时验证 SEH 链。 它验证：

- 所有异常链记录都位于堆栈边界内
- 所有例外记录都对齐
- 没有指向堆栈的异常处理程序指针
- 没有向后指针
- 异常链以已知的最终异常处理程序结束

如果这些验证失败，则异常处理将中止，并且不会处理异常。

### <a name="compatibility-considerations"></a>兼容性注意事项

SEHOP 的兼容性问题相对较少。 应用程序对损坏异常链具有依赖关系的情况并不常见。 但是，某些应用程序受计时的细微变化影响，这可能表现为在应用程序中显示潜在多线程 Bug 的竞争条件。

### <a name="configuration-options"></a>配置选项

> [!Note]
> **验证没有 (审核) SEHOP** 异常链。

## <a name="validate-handle-usage"></a>验证处理使用情况

### <a name="description"></a>说明

*验证句柄* 使用是一种缓解措施，可帮助防止攻击者使用现有句柄访问受保护的对象。 [句柄](/windows/win32/sysinfo/handles-and-objects)是一个对受保护对象的引用。 如果应用程序代码引用了无效的句柄，这可能表示攻击者试图使用它之前记录的句柄 (但哪个应用程序引用计数不会注意到) 。 如果应用程序尝试使用无效对象，而不只是返回 null，则应用程序将在 (STATUS_INVALID_HANDLE) 。

此缓解功能会自动应用于Windows应用商店应用程序。

### <a name="compatibility-considerations"></a>兼容性注意事项

未准确跟踪引用的应用程序（未在异常处理程序中包装这些操作）可能会受到此缓解的影响。

### <a name="configuration-options"></a>配置选项

> [!Note]
> **验证句柄使用情况** 没有审核模式。

## <a name="validate-heap-integrity"></a>验证堆完整性

### <a name="description"></a>说明

验证 *堆完整性* 缓解增加了Windows堆缓解的保护级别，因为如果检测到堆损坏，应用程序将终止。 缓解包括：

- 阻止释放 HEAP 句柄
- 对扩展块标头执行另一个堆分配验证
- 验证堆分配是否尚未标记为使用中
- 向最大分配、堆段和超过最小大小的子类别添加保护页面

### <a name="compatibility-considerations"></a>兼容性注意事项

默认情况下，此缓解已应用于 64 位应用程序和面向 Vista 或更高版本的 32 Windows应用程序。 来自 Windows XP 或更早版本的旧版应用程序风险最大，但兼容性问题很少见。

### <a name="configuration-options"></a>配置选项

> [!Note]
> **验证堆完整性** 没有审核模式。

## <a name="validate-image-dependency-integrity"></a>验证映像依赖项完整性

### <a name="description"></a>说明

*验证图像依赖缓解* 可帮助防范尝试替换由二进制文件静态链接的 dll Windows攻击。 DLL 技术滥用加载器的搜索机制注入恶意代码，该代码可用于使恶意代码在提升的上下文中运行。 当加载程序加载 Windows 签名的二进制文件，然后加载二进制文件依赖的任何 dll 时，将验证这些二进制文件以确保它们同样以 Windows 二进制文件形式进行数字签名。 如果它们未通过签名检查，将不会加载 dll，并且将引发异常，并返回 STATUS_INVALID_IMAGE_HASH。

### <a name="compatibility-considerations"></a>兼容性注意事项

兼容性问题并不常见。 依赖于将二进制文件Windows本地专用版本的应用程序将受到影响，并且多线程应用程序中也存在一个小的风险：显示细微的计时错误。

### <a name="configuration-options"></a>配置选项

**仅审核** - 可以在审核模式下启用此缓解，以便衡量对应用程序的潜在兼容性影响。 然后，可以在事件查看器中或在 [Microsoft Defender for Endpoint](/microsoft-365/security/defender/advanced-hunting-overview) 中使用高级搜寻查看审核事件。

## <a name="validate-stack-integrity-stackpivot"></a>验证堆栈完整性(StackPivot)

### <a name="description"></a>说明

验证堆栈完整性 *(StackPivot)* 缓解有助于抵御 Stack Pivot 攻击，这是攻击者在堆内存中创建假堆栈的 ROP 攻击，然后欺骗应用程序返回到控制执行流的虚假堆栈。

此缓解将截获Windows API，并检查堆栈指针的值。 如果堆栈指针的地址不在堆栈的底部和顶部之间，则记录事件，如果未在审核模式下，则进程将终止。

此缓解截获的 API 包括：

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

### <a name="compatibility-considerations"></a>兼容性注意事项

使用假堆栈的应用程序将受到影响，并且存在一个在多线程应用程序中显示细微计时 Bug 的较小风险。
执行 API 拦截的应用程序（尤其是安全软件）可能会导致此缓解出现兼容性问题。

此缓解与任意代码防护缓解不兼容。

### <a name="configuration-options"></a>配置选项

**仅审核** - 可以在审核模式下启用此缓解，以便衡量对应用程序的潜在兼容性影响。 然后，可以在事件查看器中或在 [Microsoft Defender for Endpoint](/microsoft-365/security/defender/advanced-hunting-overview) 中使用高级搜寻查看审核事件。
